{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Lab 5: Continuous Random Variables & Confidence Intervals\"\n",
        "subtitle: \"PSTAT 5A - Summer Session A 2025\"\n",
        "author: \"Instructor: Narjes Mathlouthi\"\n",
        "format: \n",
        "  html:\n",
        "    toc: true\n",
        "    toc-depth: 3\n",
        "    logo: /img/logo.png\n",
        "    footer: \"Continuous Variables Lab5 © 2025 Narjes Mathlouthi\"\n",
        "    number-sections: false\n",
        "    code-fold: false\n",
        "    theme: cosmo\n",
        "    css: /files/lecture_notes/theme/lecture-styles.css\n",
        "date: today\n",
        "jupyter: pstat5a\n",
        "execute: \n",
        "  eval: false\n",
        "---\n",
        "\n",
        "::: {.column-margin}\n",
        "![](/img/logo.png){width=100px}\n",
        ":::\n",
        "\n",
        "Welcome to Lab 5! Today we're moving from discrete (countable) to continuous (measurable) random variables. We'll explore the normal distribution, learn about sampling, and get our first taste of confidence intervals! \n",
        "\n",
        "# Getting Started\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 2 minutes\n",
        ":::\n",
        "\n",
        "Navigate to our class [Jupyterhub Instance](https://pstat5a.lsit.ucsb.edu/). Create a new notebook and rename it \"lab5\" (for detailed instructions view [lab1](/files/labs/lab1/lab1.pdf)). \n",
        "\n",
        ":::{.callout-note}\n",
        "### Setup\n",
        "\n",
        "First, let's load our tools! Copy the below code to get started!\n",
        "\n",
        "We’ll be using the following core libraries:\n",
        "\n",
        "- **[NumPy](https://numpy.org/doc/)**: Fundamental package for fast array-based numerical computing.  \n",
        "\n",
        "- **[Matplotlib](https://matplotlib.org/stable/contents.html)** (`pyplot`): Primary library for creating static 2D plots and figures.  \n",
        "\n",
        "\n",
        "- **[SciPy](https://docs.scipy.org/doc/scipy/reference/stats.html)** (`stats`): Collection of scientific algorithms, including probability distributions and statistical tests.  \n",
        "\n",
        "\n",
        "- **[Pandas](https://pandas.pydata.org/docs/)**: High-performance data structures (`DataFrame`) and tools for data wrangling and analysis.  \n",
        "\n",
        "\n",
        "- **[Statsmodels](https://www.statsmodels.org/stable/index.html)**: Econometric and statistical modeling for regression analysis, time series, and more.  \n",
        "\n",
        ":::\n"
      ],
      "id": "014aa215"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# Install any missing packages (will skip those already installed)\n",
        "#%pip install --quiet numpy matplotlib scipy pandas statsmodels --> uncommnent to install packages if needed\n",
        "\n",
        "# Load our tools (libraries)\n",
        "\n",
        "import numpy as np # numerical computing (arrays, random numbers, etc.)\n",
        "import matplotlib.pyplot as plt # plotting library for static 2D graphs and visualizations\n",
        "from scipy import stats #  statistical functions (distributions, tests, etc.)\n",
        "import pandas as pd # data structures (DataFrame) and data analysis tools\n",
        "import statsmodels  # statistical modeling (regression, time series, ANOVA, etc.)\n",
        "\n",
        "# Make our graphs look nice\n",
        "\n",
        "#!%matplotlib inline     # uncommnent to embed Matplotlib plots directly in the notebook\n",
        "plt.style.use('seaborn-v0_8-whitegrid')  # Apply a clean whitegrid style from Seaborn\n",
        "\n",
        "# Set random seed for reproducible results\n",
        "\n",
        "np.random.seed(42)    # fix the random seed so results can be reproduced exactly\n",
        "\n",
        "print(\"✅ All tools loaded successfully!\") "
      ],
      "id": "ff798d68",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-note}\n",
        "**New for today:** We'll use the same tools but focus on **continuous distributions** - where variables can take any value in a range (like height, weight, temperature) rather than just counting things.\n",
        ":::\n",
        "\n",
        "# Part 1: Discrete vs. Continuous - What's the Difference?\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 8 minutes\n",
        ":::\n",
        "\n",
        "## Understanding the Difference\n",
        "\n",
        "Let's start by understanding what makes a variable continuous:"
      ],
      "id": "bc9ad3ba"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# Examples of different variable types\n",
        "print(\"DISCRETE VARIABLES (countable):\")\n",
        "print(\"• Number of students in class: 0, 1, 2, 3, ...\")\n",
        "print(\"• Number of emails received: 0, 1, 2, 3, ...\")\n",
        "print(\"• Number of coin flips showing heads: 0, 1, 2, 3, ...\")\n",
        "print()\n",
        "print(\"CONTINUOUS VARIABLES (measurable):\")\n",
        "print(\"• Height: 5.5 ft, 5.73 ft, 6.02541 ft, ...\")\n",
        "print(\"• Temperature: 72.1°F, 72.15°F, 72.152°F, ...\")\n",
        "print(\"• Time: 2.5 seconds, 2.51 seconds, ...\")"
      ],
      "id": "4d920549",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Key Difference: PMF vs PDF\n",
        "\n",
        "::: {.callout-important}\n",
        "**Important Distinction:**\n",
        "\n",
        "- **Discrete:** Use **PMF** (Probability Mass Function) - gives exact probabilities\n",
        "  - Example: P(exactly 3 heads) = 0.125\n",
        "\n",
        "- **Continuous:** Use **PDF** (Probability Density Function) - gives probability *densities*\n",
        "  - Example: P(exactly 5.000000... feet) = 0 (impossible!)\n",
        "  - Instead: P(between 5.0 and 5.1 feet) = some value\n",
        "\n",
        "**Key insight:** For continuous variables, we calculate probabilities over *ranges*, not exact values!\n",
        ":::\n",
        "\n",
        "Let's visualize this difference:\n",
        "\n",
        "::: {.callout-note}\n",
        "### What we're doing\n",
        "We call [`plt.subplots(nrows=1, ncols=2, figsize=(12, 5))`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.subplots.html) to create **one row** and **two columns** of plots, sized so the overall figure is 12 inches wide by 5 inches tall.\n",
        "\n",
        "We first define the key **parameters** for a **binomial** distribution with `n` (number of trials) and `p` (success probability).\n",
        "\n",
        "Then, we create a probability mass function (PMF) by first generating  all possible outcomes from 0 to 11 using [`np.arange()`](https://numpy.org/doc/stable/reference/generated/numpy.arange.html):\n",
        "\n",
        "```python\n",
        "# Create outcomes from 0 to n (inclusive)\n",
        "x_discrete = np.arange(0, n+1)\n",
        "```\n",
        "\n",
        ":::{.callout-important}\n",
        "For a binomial distribution with $10$ trials, the possible number of successes are: <br>\n",
        "\n",
        "$0 \\quad \\text{successes}, 1 \\quad \\text{success}, 2 \\quad \\text{successes}, ..., 10 \\quad \\text{successes}$ <br>\n",
        "That's $11$ different outcomes total (0 through 10 inclusive). <br>\n",
        "When we use `np.arange(0, 11)`, we get: $[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]$ <br>\n",
        "If we mistakenly used `np.arange(0, 10)`, we'd get: $[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]$ and miss the case where all $10$ trials are successes!\n",
        ":::\n",
        "\n",
        "Once we have our values, we compute the PMF using  \n",
        "   ```python\n",
        "   y_discrete = stats.binom(n, p).pmf(x_discrete)\n",
        "   ```  \n",
        "from SciPy’s [`stats.binom`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.binom.html). \n",
        "\n",
        "Lastly, we plot these probabilities as a bar chart on the **left** subplot.  \n",
        "\n",
        "Next to illustrate a continuous random variable (i.e., Standard Normal), we start by creating the range of values needed to create a probability density function (PDF). We create a smooth grid of values with\n",
        "\n",
        "```python\n",
        "x_continuous = np.linspace(-4, 4, 1000)\n",
        "```  \n",
        "via [`np.linspace()`](https://numpy.org/doc/stable/reference/generated/numpy.linspace.html) (recall we used this function in [lab3](/files/labs/lab3/lab3.qmd)).  \n",
        "\n",
        "Then, compute the PDF using  \n",
        "```python\n",
        "y_continuous = stats.norm(0, 1).pdf(x_continuous)\n",
        "```  \n",
        "from SciPy’s [`stats.norm`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.norm.html).  \n",
        "\n",
        "Lastly, we draw the curve and shade underneath on the **right** subplot.  \n",
        " \n",
        "Optional: [`plt.tight_layout()`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.tight_layout.html) to automatically adjust spacing so that titles, labels, and ticks don’t overlap.\n",
        "\n",
        ":::\n"
      ],
      "id": "f1079146"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# Create a figure with 1 row and 2 columns of axes, total size 12x5 inches\n",
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n",
        "\n",
        "\n",
        "# ── Discrete example: Binomial distribution ────────────────────────────────────\n",
        "\n",
        "n, p = 10, 0.5                             # number of trials and success probability\n",
        "x_discrete = np.arange(0, 11)              # possible counts: 0 through 10 heads\n",
        "y_discrete = stats.binom(n, p).pmf(x_discrete)  # compute PMF at each count\n",
        "\n",
        "ax1.bar(\n",
        "    x_discrete, y_discrete,                # x-values and their probabilities\n",
        "    alpha=0.7,                             # make bars semi-transparent\n",
        "    color='lightblue',                     # fill color for the bars\n",
        "    edgecolor='black'                      # outline color for clarity\n",
        ")\n",
        "ax1.set_title('DISCRETE: Number of Heads in 10 Flips')  # subplot title\n",
        "ax1.set_xlabel('Number of Heads')         # x-axis label\n",
        "ax1.set_ylabel('Probability (PMF)')       # y-axis label\n",
        "ax1.grid(True, alpha=0.3)                 # light grid lines for readability\n",
        "\n",
        "# ── Continuous example: Normal distribution ───────────────────────────────────\n",
        "\n",
        "x_continuous = np.linspace(-4, 4, 1000)    # 1000 points between -4 and +4\n",
        "y_continuous = stats.norm(0, 1).pdf(x_continuous)  # standard normal PDF values\n",
        "\n",
        "ax2.plot(\n",
        "    x_continuous, y_continuous,            # x-values and density values\n",
        "    'b-',                                  # blue solid line\n",
        "    linewidth=2                            # thicker line width for emphasis\n",
        ")\n",
        "ax2.fill_between(\n",
        "    x_continuous, y_continuous,            # shade area under the curve\n",
        "    alpha=0.3,                             # semi-transparent fill\n",
        "    color='lightgreen'                     # fill color\n",
        ")\n",
        "ax2.set_title('CONTINUOUS: Standard Normal Distribution')  # subplot title\n",
        "ax2.set_xlabel('Value')                   # x-axis label\n",
        "ax2.set_ylabel('Density (PDF)')           # y-axis label\n",
        "ax2.grid(True, alpha=0.3)                 # light grid lines for readability\n",
        "\n",
        "plt.tight_layout()                         # adjust spacing so titles/labels don’t overlap"
      ],
      "id": "f9668abe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Part 2: The Normal Distribution - The Most Important One!\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 15 minutes\n",
        ":::\n",
        "\n",
        "The **normal distribution** is everywhere! Heights, test scores, measurement errors; they all tend to follow this bell-shaped pattern.\n",
        "\n",
        "## Standard Normal Distribution\n",
        "\n",
        "Let's start with the **standard normal**: mean = 0, standard deviation = 1.\n",
        "\n",
        ":::{.callout-tip}\n",
        "### Recall\n",
        "The standard normal distribution $N(0,1)$ is obtained by the linear transformation  \n",
        "$$\n",
        "Z = \\frac{X - \\mu}{\\sigma},\n",
        "$$  \n",
        "which removes units by centering at zero and scaling to unit variance. Its PDF is  \n",
        "$$\n",
        "\\phi(z) = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2}.\n",
        "$$\n",
        "\n",
        ":::\n",
        "\n",
        "In SciPy, you can create or shift any normal distribution using the `loc` (mean) and `scale` (standard deviation) parameters of [`stats.norm`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.norm.html).  In particular, evaluating\n",
        "\n",
        "```python\n",
        "stats.norm.pdf(x, loc, scale)\n",
        "```\n",
        "\n",
        "is equivalent to \n",
        "\n",
        "```python\n",
        "y = stats.norm(loc=loc, scale=scale).pdf(x)\n",
        "```\n",
        "and under the hood it computes\n",
        "\n",
        "$$\n",
        "y = \\frac{1}{\\sigma},\\phi (z) =\\Bigl(\\frac{x - \\mu}{\\sigma}\\Bigr)\n",
        "$$\n",
        "\n",
        "where $\\phi(z)$ is the standard normal PDF.\n"
      ],
      "id": "d13ab066"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "\n",
        "# Create a standard normal distribution\n",
        "standard_normal = stats.norm(loc=0, scale=1)  # loc=mean, scale=standard deviation\n",
        "\n",
        "print(\"Standard Normal Distribution:\")\n",
        "print(f\"Mean: {standard_normal.mean()}\")\n",
        "print(f\"Standard deviation: {standard_normal.std()}\")\n",
        "\n",
        "# Generate a smooth range of x-values from -4 to +4\n",
        "x = np.linspace(-4, 4, 1000)       # 1000 points for a smooth curve \n",
        "y = standard_normal.pdf(x) # compute the pdf\n",
        "\n",
        "# Plot the PDF\n",
        "plt.figure(figsize=(10, 6))        # figure size in inches\n",
        "plt.plot(\n",
        "    x, y,                           # x-values and PDF values\n",
        "    'b-',                          # blue solid line\n",
        "    linewidth=2,\n",
        "    label=r'Standard Normal: $\\mu=0,\\ \\sigma=1$'  # legend with LaTeX\n",
        ")\n",
        "plt.fill_between(\n",
        "    x, y,                          # shade under the PDF curve\n",
        "    alpha=0.3,\n",
        "    color='lightblue'\n",
        ")\n",
        "plt.title(r'Standard Normal Distribution $(\\mu=0,\\ \\sigma=1)$')  # title with LaTeX\n",
        "plt.xlabel('Value')               # x-axis label\n",
        "plt.ylabel('Density')             # y-axis label\n",
        "plt.axvline(\n",
        "    0,                             # vertical line at x=0\n",
        "    color='red',\n",
        "    linestyle='--',\n",
        "    linewidth=2,\n",
        "    label=r'Mean $\\mu=0$'          # legend entry for the mean line\n",
        ")\n",
        "plt.legend()                      # display legend\n",
        "plt.grid(True, alpha=0.3)         # add light grid lines"
      ],
      "id": "97975fb6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Calculating Probabilities with Areas\n",
        "\n",
        ":::{.callout-important}\n",
        "For continuous distributions, probability = area under the curve!\n",
        ":::\n",
        "\n",
        "That is, the probability that $(X)$ falls between $(a)$ and $(b)$ is the area under the PDF from $(x=a)$ to $(x=b)$.  `SciPy`’s `stats.norm.cdf` computes the cumulative distribution function (CDF)\n",
        "\n",
        "$$\n",
        "F(x) = P(X \\le x) = \\int_{-\\infty}^x \\phi(t),dt\n",
        "$$\n",
        "\n",
        "Therefore,\n",
        "\n",
        "$$\n",
        "P(a < X < b) = F(b) - F(a)\n",
        "$$\n"
      ],
      "id": "80dfc99a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# Probability that a value is between -1 and 1 - P(-1 < X < 1) for X ~ N(0,1\n",
        "prob_between = standard_normal.cdf(1) - standard_normal.cdf(-1)\n",
        "print(f\"P(-1 < X < 1) = {prob_between:.4f}\")\n",
        "\n",
        "# Visualize this probability\n",
        "x = np.linspace(-4, 4, 1000)\n",
        "y = standard_normal.pdf(x)\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(x, y, 'b-', linewidth=2, label='Standard Normal')\n",
        "\n",
        "# Shade the area between -1 and 1\n",
        "x_fill = x[(x >= -1) & (x <= 1)]\n",
        "y_fill = standard_normal.pdf(x_fill)\n",
        "plt.fill_between(x_fill, y_fill, alpha=0.5, color='red', \n",
        "                label=f'P(-1 < X < 1) = {prob_between:.4f}')\n",
        "\n",
        "plt.title('Probability as Area Under the Curve')\n",
        "plt.xlabel('Value')\n",
        "plt.ylabel('Density')\n",
        "plt.axvline(-1, color='red', linestyle='--', alpha=0.7)\n",
        "plt.axvline(1, color='red', linestyle='--', alpha=0.7)\n",
        "plt.legend()\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.show()"
      ],
      "id": "982ec561",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.task-box}\n",
        "### Task 1: Your First Normal Distribution\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 6 minutes\n",
        ":::\n",
        "\n",
        "Let's say human heights follow a normal distribution with mean = 68 inches and standard deviation = 4 inches.\n",
        "\n",
        "Copy the code and try it on your own!\n",
        "\n",
        "**Step 1:** Create this distribution"
      ],
      "id": "562e6d96"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "# Heights distribution\n",
        "mean_height = ___  # Fill in: 68\n",
        "std_height = ___   # Fill in: 4\n",
        "\n",
        "heights = stats.norm(loc=___, scale=___)\n",
        "\n",
        "print(f\"Mean height: {heights.mean()} inches\")\n",
        "print(f\"Standard deviation: {heights.std()} inches\")"
      ],
      "id": "2c35c139",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Step 2:** Calculate some probabilities"
      ],
      "id": "37f1c615"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "# a) What's the probability someone is taller than 72 inches (6 feet)?\n",
        "prob_tall = 1 - heights.cdf(___)  # Fill in: 72\n",
        "print(f\"P(height > 72 inches) = {prob_tall:.4f}\")\n",
        "\n",
        "# b) What's the probability someone is between 64 and 72 inches?\n",
        "prob_between = heights.cdf(___) - heights.cdf(___)  # Fill in both values\n",
        "print(f\"P(64 < height < 72) = {prob_between:.4f}\")\n",
        "\n",
        "# c) What height is at the 90th percentile? (90% of people are shorter)\n",
        "height_90th = heights.ppf(___)  # ppf = \"percent point function\" (inverse of cdf)\n",
        "print(f\"90th percentile height: {height_90th:.2f} inches\")"
      ],
      "id": "2b0f77b4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Step 3:** Make a visualization"
      ],
      "id": "8b99f3c8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "# Plot the height distribution\n",
        "x = np.linspace(50, 86, 1000)\n",
        "y = heights.pdf(x)\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(x, y, 'b-', linewidth=2)\n",
        "plt.fill_between(x, y, alpha=0.3, color='lightgreen')\n",
        "plt.title('Human Heights Distribution')\n",
        "plt.xlabel('Height (inches)')\n",
        "plt.ylabel('Density')\n",
        "plt.axvline(mean_height, color='red', linestyle='--', linewidth=2, \n",
        "           label=f'Mean = {mean_height} inches')\n",
        "plt.legend()\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.show()"
      ],
      "id": "8fa1862c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## The 68-95-99.7 Rule\n",
        "\n",
        "This rule (also called the **empirical rule**) describes how data are distributed in a normal distribution:\n",
        "\n",
        "- About **68%** of observations fall within **one** standard deviation of the mean ($\\mu \\pm 1\\sigma$).\n",
        "- About **95%** lie within **two** standard deviations ($\\mu \\pm 2\\sigma$).\n",
        "- Nearly **99.7%** lie within **three** standard deviations ($\\mu \\pm 3\\sigma$).\n",
        "\n",
        "In practice, this gives a quick way to gauge how “typical” a value is: if a point lies beyond $\\pm 2\\sigma$, it’s already in the outer 5% and might be considered unusual or an outlier."
      ],
      "id": "83215a8b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# The 68-95-99.7 rule for standard normal\n",
        "mean, std = 0, 1\n",
        "\n",
        "prob_68 = stats.norm.cdf(1) - stats.norm.cdf(-1)  # Within 1 std dev\n",
        "prob_95 = stats.norm.cdf(2) - stats.norm.cdf(-2)  # Within 2 std devs\n",
        "prob_997 = stats.norm.cdf(3) - stats.norm.cdf(-3) # Within 3 std devs\n",
        "\n",
        "print(\"The 68-95-99.7 Rule:\")\n",
        "print(f\"• About {prob_68:.1%} of data is within 1 standard deviation\")\n",
        "print(f\"• About {prob_95:.1%} of data is within 2 standard deviations\") \n",
        "print(f\"• About {prob_997:.1%} of data is within 3 standard deviations\")\n",
        "\n",
        "# Visualize the rule\n",
        "x = np.linspace(-4, 4, 1000)\n",
        "y = stats.norm.pdf(x)\n",
        "\n",
        "fig, axes = plt.subplots(1, 3, figsize=(15, 4))\n",
        "\n",
        "# 68% (1 std dev)\n",
        "axes[0].plot(x, y, 'b-', linewidth=2)\n",
        "x1 = x[(x >= -1) & (x <= 1)]\n",
        "axes[0].fill_between(x1, stats.norm.pdf(x1), alpha=0.5, color='green')\n",
        "axes[0].set_title('68% within 1 σ')\n",
        "axes[0].axvline(-1, color='red', linestyle='--')\n",
        "axes[0].axvline(1, color='red', linestyle='--')\n",
        "\n",
        "# 95% (2 std devs)\n",
        "axes[1].plot(x, y, 'b-', linewidth=2)\n",
        "x2 = x[(x >= -2) & (x <= 2)]\n",
        "axes[1].fill_between(x2, stats.norm.pdf(x2), alpha=0.5, color='orange')\n",
        "axes[1].set_title('95% within 2 σ')\n",
        "axes[1].axvline(-2, color='red', linestyle='--')\n",
        "axes[1].axvline(2, color='red', linestyle='--')\n",
        "\n",
        "# 99.7% (3 std devs)\n",
        "axes[2].plot(x, y, 'b-', linewidth=2)\n",
        "x3 = x[(x >= -3) & (x <= 3)]\n",
        "axes[2].fill_between(x3, stats.norm.pdf(x3), alpha=0.5, color='purple')\n",
        "axes[2].set_title('99.7% within 3 σ')\n",
        "axes[2].axvline(-3, color='red', linestyle='--')\n",
        "axes[2].axvline(3, color='red', linestyle='--')\n",
        "\n",
        "for ax in axes:\n",
        "    ax.set_ylim(0, 0.45)\n",
        "    ax.grid(True, alpha=0.3)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "01d140b2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Part 3: Other Continuous Distributions\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 10 minutes\n",
        ":::\n",
        "\n",
        "## Uniform Distribution\n",
        "\n",
        "The **uniform distribution** on an interval $[a,b]$ assigns equal probability density to every point between $a$ and $b$.  Its PDF is  \n",
        "$$\n",
        "f(x) = \\begin{cases}\n",
        "\\frac{1}{b - a}, & a \\le x \\le b,\\\\\n",
        "0, & \\text{otherwise},\n",
        "\\end{cases}\n",
        "$$\n",
        "\n",
        "so the probability of any subinterval is simply its length divided by $(b-a)$.  In SciPy, you specify this with `loc=a` and `scale=(b - a)` when calling [`stats.uniform`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.uniform.html).\n",
        "\n",
        "Let's visualize this:\n"
      ],
      "id": "b9da439c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# Uniform distribution between 0 and 10\n",
        "uniform_dist = stats.uniform(loc=0, scale=10)  # loc=start, scale=width\n",
        "\n",
        "print(f\"Uniform distribution from 0 to 10:\")\n",
        "print(f\"Mean: {uniform_dist.mean()}\")\n",
        "print(f\"Standard deviation: {uniform_dist.std():.2f}\")\n",
        "\n",
        "# Plot it\n",
        "x = np.linspace(-1, 11, 1000)\n",
        "y = uniform_dist.pdf(x)\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(x, y, 'b-', linewidth=3, label='Uniform(0, 10)')\n",
        "plt.fill_between(x, y, alpha=0.3, color='yellow')\n",
        "plt.title('Uniform Distribution: All Values Equally Likely')\n",
        "plt.xlabel('Value')\n",
        "plt.ylabel('Density')\n",
        "plt.legend()\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.show()\n",
        "\n",
        "# Calculate a probability\n",
        "prob_middle = uniform_dist.cdf(7) - uniform_dist.cdf(3)\n",
        "print(f\"P(3 < X < 7) = {prob_middle:.2f}\")"
      ],
      "id": "b7e8a6d0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Exponential Distribution\n",
        "\n",
        "The **exponential distribution** gives the probability of waiting time until the next event (for example, the time between customer arrivals) and is controlled by a single **rate** parameter $\\lambda$. Its probability density function (PDF) is\n",
        "\n",
        "$$\n",
        "f(x) \\;=\\; \\lambda\\,e^{-\\lambda x}, \n",
        "\\quad x \\ge 0,\n",
        "$$\n",
        "\n",
        "so the chance of a short wait ($x$ small) is high and it decays exponentially for longer waits. The **average** waiting time is $1/\\lambda$.  \n",
        "\n",
        "In `SciPy`, you can create this via:\n",
        "\n",
        "```python\n",
        "from scipy import stats\n",
        "rate = 0.5              # for example, 0.5 events per unit time\n",
        "exp_dist = stats.expon(scale=1/rate)  # scale = 1/λ\n",
        "```\n",
        "\n",
        "Here is a quick example visualization of the exponential distribution :"
      ],
      "id": "bd412b6f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# Exponential distribution - models time between events\n",
        "# Parameter λ (lambda) = rate parameter\n",
        "rate = 0.5  # events per unit time\n",
        "exponential_dist = stats.expon(scale=1/rate)  # scale = 1/rate\n",
        "\n",
        "print(f\"Exponential distribution (rate = {rate}):\")\n",
        "print(f\"Mean waiting time: {exponential_dist.mean():.2f}\")\n",
        "\n",
        "# Plot it\n",
        "x = np.linspace(0, 10, 1000)\n",
        "y = exponential_dist.pdf(x)\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(x, y, 'b-', linewidth=2, label='Exponential (λ=0.5)')\n",
        "plt.fill_between(x, y, alpha=0.3, color='pink')\n",
        "plt.title('Exponential Distribution: Waiting Times')\n",
        "plt.xlabel('Time')\n",
        "plt.ylabel('Density')\n",
        "plt.legend()\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.show()\n",
        "\n",
        "# Probability of waiting less than 2 time units\n",
        "prob_short_wait = exponential_dist.cdf(2)\n",
        "print(f\"P(wait time < 2) = {prob_short_wait:.4f}\")"
      ],
      "id": "b4dc39d9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.task-box}\n",
        "### Task 2: Bus Waiting Times\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 4 minutes\n",
        ":::\n",
        "\n",
        "The time between buses follows an exponential distribution with an average of 15 minutes between buses.\n",
        "Copy the code and try it on your own!"
      ],
      "id": "cfbe6b02"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "# Bus waiting times\n",
        "average_wait = ___  # Fill in: 15 minutes\n",
        "rate = 1 / average_wait\n",
        "bus_times = stats.expon(scale=___)  # Fill in: average_wait\n",
        "\n",
        "# Questions:\n",
        "# a) What's the probability you wait less than 10 minutes?\n",
        "prob_short = bus_times.cdf(___)\n",
        "print(f\"P(wait < 10 min) = {prob_short:.4f}\")\n",
        "\n",
        "# b) What's the probability you wait more than 30 minutes?\n",
        "prob_long = 1 - bus_times.cdf(___)\n",
        "print(f\"P(wait > 30 min) = {prob_long:.4f}\")\n",
        "\n",
        "# c) What's the median waiting time? (50th percentile)\n",
        "median_wait = bus_times.ppf(___)  # Fill in: 0.5\n",
        "print(f\"Median wait time: {median_wait:.2f} minutes\")"
      ],
      "id": "1e05444b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "# Part 4: Sampling and the Central Limit Theorem\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 12 minutes\n",
        ":::\n",
        "\n",
        "Here's where things get really cool! Let's see what happens when we take samples from populations.\n",
        "\n",
        "## The Magic of Sample Means\n",
        "\n",
        ":::{.callout-note}\n",
        "### What we’re doing\n",
        " \n",
        "1. We define a skewed population (Exponential) with mean = 2 to illustrate a non-normal distribution.\n",
        "2. We plot the population PDF to see its right skew.\n",
        "3. We draw many samples of size `sample_size`, compute each sample’s mean, and collect those means.\n",
        "4. We plot the distribution of those sample means to show how they approximate a normal distribution.\n",
        "5. We repeat this process for smaller and larger sample sizes to see how sample size affects the shape (normality) and spread (standard error) of the sample means.\n",
        ":::"
      ],
      "id": "e708f27b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# 1) Define a skewed population: Exponential with scale=2 (mean=2)\n",
        "population = stats.expon(scale=2)  # Mean = 2, very right-skewed\n",
        "\n",
        "# Display the population's true mean and std dev\n",
        "print(\"Original Population (Exponential):\")\n",
        "print(f\"Population mean: {population.mean()}\")\n",
        "print(f\"Population std: {population.std():.3f}\")\n",
        "\n",
        "# Prepare x-values to plot the population PDF\n",
        "x = np.linspace(0, 15, 1000)\n",
        "# Compute population PDF values\n",
        "y = population.pdf(x)\n",
        "\n",
        "plt.figure(figsize=(12, 8))\n",
        "\n",
        "# Plot 1: Population PDF\n",
        "plt.subplot(2, 2, 1)\n",
        "plt.plot(x, y, 'r-', linewidth=2)\n",
        "plt.fill_between(x, y, alpha=0.3, color='red')\n",
        "plt.title('Population: Exponential (Skewed!)')\n",
        "plt.xlabel('Value')\n",
        "plt.ylabel('Density')\n",
        "\n",
        "# 2) Simulate sampling: draw n_samples of size sample_size\n",
        "sample_size = 30  # Size of each sample\n",
        "n_samples = 1000  # Number of samples to take\n",
        "\n",
        "sample_means = []\n",
        "for i in range(n_samples):\n",
        "    #   a) Take one sample of size sample_size\n",
        "    sample = population.rvs(sample_size)  # rvs = random variates (samples)\n",
        "    #   b) Compute the sample mean\n",
        "    sample_mean = np.mean(sample)\n",
        "    sample_means.append(sample_mean)\n",
        "\n",
        "print(f\"\\nSample Means (n={sample_size}, {n_samples} samples):\")\n",
        "print(f\"Mean of sample means: {np.mean(sample_means):.3f}\")\n",
        "print(f\"Std of sample means: {np.std(sample_means):.3f}\")\n",
        "\n",
        "# Plot 2: Distribution of sample means for n=sample_size\n",
        "plt.subplot(2, 2, 2)\n",
        "plt.hist(sample_means, bins=50, density=True, alpha=0.7, color='green', edgecolor='black')\n",
        "plt.title('Distribution of Sample Means\\n(Notice: It\\'s Normal!)')\n",
        "plt.xlabel('Sample Mean')\n",
        "plt.ylabel('Density')\n",
        "\n",
        "# 3) Repeat sampling with smaller sample size to illustrate increased variability\n",
        "small_sample_size = 5\n",
        "small_sample_means = []\n",
        "for i in range(n_samples):\n",
        "    sample = population.rvs(small_sample_size)\n",
        "    small_sample_means.append(np.mean(sample))\n",
        "\n",
        "plt.subplot(2, 2, 3)\n",
        "plt.hist(small_sample_means, bins=50, density=True, alpha=0.7, color='orange', edgecolor='black')\n",
        "plt.title(f'Sample Means (n={small_sample_size})\\n(Less normal, more spread)')\n",
        "plt.xlabel('Sample Mean')\n",
        "plt.ylabel('Density')\n",
        "\n",
        "# 4) Repeat sampling with larger sample size to illustrate reduced variability\n",
        "large_sample_size = 100\n",
        "large_sample_means = []\n",
        "for i in range(n_samples):\n",
        "    sample = population.rvs(large_sample_size)\n",
        "    large_sample_means.append(np.mean(sample))\n",
        "\n",
        "plt.subplot(2, 2, 4)\n",
        "plt.hist(large_sample_means, bins=50, density=True, alpha=0.7, color='blue', edgecolor='black')\n",
        "plt.title(f'Sample Means (n={large_sample_size})\\n(Very normal, less spread)')\n",
        "plt.xlabel('Sample Mean')\n",
        "plt.ylabel('Density')\n",
        "\n",
        "# Finalize layout and display all four plots\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "e5a30cd0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-important}\n",
        "## Central Limit Theorem (CLT)\n",
        "\n",
        "**Amazing fact:** No matter what shape your population has, if you take many samples and calculate their means, those sample means will be approximately normally distributed!\n",
        "\n",
        "**The bigger your sample size, the more normal it gets!**\n",
        "\n",
        "If $\\bar{X}$ is the sample mean from a population with mean $\\mu$ and standard deviation $\\sigma$, then:\n",
        "\n",
        "$$\\bar{X} \\sim \\text{Normal}\\left(\\mu, \\frac{\\sigma}{\\sqrt{n}}\\right)$$\n",
        "\n",
        "Where $n$ is the sample size.\n",
        ":::\n",
        "\n",
        "::: {.task-box}\n",
        "### Task 3: Explore the CLT\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 6 minutes\n",
        ":::\n",
        "\n",
        "Let's verify the Central Limit Theorem with a different population!\n",
        "Copy the code and try it on your own!"
      ],
      "id": "9c8e28bb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "# Population: Uniform distribution from 0 to 100\n",
        "population = stats.uniform(loc=0, scale=100)\n",
        "\n",
        "print(\"Population (Uniform 0 to 100):\")\n",
        "print(f\"Population mean: {population.mean()}\")\n",
        "print(f\"Population std: {population.std():.2f}\")\n",
        "\n",
        "# Take 500 samples of size 25 each\n",
        "sample_size = ___  # Fill in: 25\n",
        "n_samples = ___    # Fill in: 500\n",
        "\n",
        "sample_means = []\n",
        "for i in range(n_samples):\n",
        "    sample = population.rvs(___)  # Fill in: sample_size\n",
        "    sample_means.append(np.mean(sample))\n",
        "\n",
        "# Check the CLT prediction\n",
        "predicted_mean = population.mean()\n",
        "predicted_std = population.std() / np.sqrt(sample_size)\n",
        "\n",
        "print(f\"\\nCLT Predictions:\")\n",
        "print(f\"Sample means should have mean ≈ {predicted_mean:.2f}\")\n",
        "print(f\"Sample means should have std ≈ {predicted_std:.2f}\")\n",
        "\n",
        "print(f\"\\nActual Results:\")\n",
        "print(f\"Sample means actually have mean = {np.mean(sample_means):.2f}\")\n",
        "print(f\"Sample means actually have std = {np.std(sample_means):.2f}\")\n",
        "\n",
        "# Make a histogram\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.hist(sample_means, bins=30, density=True, alpha=0.7, color='purple', edgecolor='black')\n",
        "plt.title('Distribution of Sample Means from Uniform Population')\n",
        "plt.xlabel('Sample Mean')\n",
        "plt.ylabel('Density')\n",
        "plt.axvline(np.mean(sample_means), color='red', linestyle='--', linewidth=2, \n",
        "           label=f'Actual mean = {np.mean(sample_means):.2f}')\n",
        "plt.legend()\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.show()"
      ],
      "id": "020eac25",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "# Part 5: Introduction to Confidence Intervals\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 15 minutes\n",
        ":::\n",
        "\n",
        "Now we get to one of the most practical parts of statistics: **confidence intervals**!\n",
        "\n",
        "## The Problem\n",
        "\n",
        "Imagine you want to know the average height of all students at UCSB (the population mean), but you can only measure a sample of 50 students. Your sample mean is 67.2 inches. \n",
        "\n",
        "**Question:** What can you say about the true population mean?\n",
        "\n",
        "## The Solution: Confidence Intervals"
      ],
      "id": "ec0ee1e6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# Simulate the scenario\n",
        "np.random.seed(123)\n",
        "\n",
        "# Unknown population (we pretend we don't know this)\n",
        "true_population_mean = 68.0\n",
        "true_population_std = 4.0\n",
        "true_population = stats.norm(true_population_mean, true_population_std)\n",
        "\n",
        "# We take ONE sample (this is what we'd really do)\n",
        "sample_size = 50\n",
        "our_sample = true_population.rvs(sample_size)\n",
        "sample_mean = np.mean(our_sample)\n",
        "sample_std = np.std(our_sample, ddof=1)  # ddof=1 for sample std dev\n",
        "\n",
        "print(\"What we observe from our sample:\")\n",
        "print(f\"Sample size: {sample_size}\")\n",
        "print(f\"Sample mean: {sample_mean:.2f} inches\")\n",
        "print(f\"Sample std dev: {sample_std:.2f} inches\")\n",
        "print()\n",
        "print(\"What we DON'T know (but want to estimate):\")\n",
        "print(f\"True population mean: {true_population_mean} inches\")"
      ],
      "id": "91fb7117",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Building a 95% Confidence Interval"
      ],
      "id": "7347c08a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# The Central Limit Theorem tells us that sample means are normally distributed\n",
        "# with mean = population mean and std = population_std / sqrt(n)\n",
        "\n",
        "# For a 95% confidence interval, we need the 97.5th percentile of standard normal\n",
        "# (because we want 2.5% in each tail, leaving 95% in the middle)\n",
        "confidence_level = 0.95\n",
        "alpha = 1 - confidence_level\n",
        "z_critical = stats.norm.ppf(1 - alpha/2)  # 1.96 for 95% confidence\n",
        "\n",
        "print(f\"For {confidence_level*100}% confidence:\")\n",
        "print(f\"Critical value (z*): {z_critical:.3f}\")\n",
        "\n",
        "# Standard error of the mean\n",
        "standard_error = sample_std / np.sqrt(sample_size)\n",
        "print(f\"Standard error: {standard_error:.3f}\")\n",
        "\n",
        "# Margin of error\n",
        "margin_of_error = z_critical * standard_error\n",
        "print(f\"Margin of error: {margin_of_error:.3f}\")\n",
        "\n",
        "# Confidence interval\n",
        "ci_lower = sample_mean - margin_of_error\n",
        "ci_upper = sample_mean + margin_of_error\n",
        "\n",
        "print(f\"\\n95% Confidence Interval for population mean:\")\n",
        "print(f\"[{ci_lower:.2f}, {ci_upper:.2f}] inches\")\n",
        "print()\n",
        "print(f\"Interpretation: We are 95% confident that the true population\")\n",
        "print(f\"mean height is between {ci_lower:.2f} and {ci_upper:.2f} inches.\")\n",
        "\n",
        "# Check if it captured the true mean\n",
        "if ci_lower <= true_population_mean <= ci_upper:\n",
        "    print(f\"✅ SUCCESS! Our interval captured the true mean ({true_population_mean})!\")\n",
        "else:\n",
        "    print(f\"❌ Oops! Our interval missed the true mean ({true_population_mean}).\")"
      ],
      "id": "4d47dece",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Visualizing Confidence Intervals"
      ],
      "id": "75d5c1d7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# Let's see what \"95% confidence\" really means\n",
        "# We'll create 20 different confidence intervals and see how many capture the truth\n",
        "\n",
        "n_intervals = 20\n",
        "sample_size = 30\n",
        "\n",
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 8))\n",
        "\n",
        "# Generate multiple confidence intervals\n",
        "intervals = []\n",
        "captures = []\n",
        "\n",
        "for i in range(n_intervals):\n",
        "    # Take a new sample each time\n",
        "    sample = true_population.rvs(sample_size)\n",
        "    sample_mean = np.mean(sample)\n",
        "    sample_std = np.std(sample, ddof=1)\n",
        "    \n",
        "    # Calculate 95% CI\n",
        "    se = sample_std / np.sqrt(sample_size)\n",
        "    me = 1.96 * se\n",
        "    ci_low = sample_mean - me\n",
        "    ci_high = sample_mean + me\n",
        "    \n",
        "    intervals.append((ci_low, ci_high, sample_mean))\n",
        "    captures.append(ci_low <= true_population_mean <= ci_high)\n",
        "\n",
        "# Plot the intervals\n",
        "ax1.axvline(true_population_mean, color='red', linewidth=3, \n",
        "           label=f'True Population Mean = {true_population_mean}')\n",
        "\n",
        "for i, (low, high, mean) in enumerate(intervals):\n",
        "    color = 'green' if captures[i] else 'red'\n",
        "    alpha = 0.8 if captures[i] else 1.0\n",
        "    \n",
        "    # Plot the confidence interval\n",
        "    ax1.plot([low, high], [i, i], color=color, linewidth=3, alpha=alpha)\n",
        "    # Plot the sample mean\n",
        "    ax1.plot(mean, i, 'o', color=color, markersize=6, alpha=alpha)\n",
        "\n",
        "ax1.set_xlabel('Height (inches)')\n",
        "ax1.set_ylabel('Sample Number')\n",
        "ax1.set_title(f'20 Different 95% Confidence Intervals\\n{sum(captures)} out of {n_intervals} captured the true mean')\n",
        "ax1.legend()\n",
        "ax1.grid(True, alpha=0.3)\n",
        "\n",
        "# Show our specific sample\n",
        "ax2.hist(our_sample, bins=10, alpha=0.7, color='lightblue', edgecolor='black', density=True)\n",
        "ax2.axvline(sample_mean, color='blue', linewidth=3, label=f'Sample Mean = {sample_mean:.2f}')\n",
        "ax2.axvline(ci_lower, color='red', linestyle='--', linewidth=2, label=f'95% CI: [{ci_lower:.2f}, {ci_upper:.2f}]')\n",
        "ax2.axvline(ci_upper, color='red', linestyle='--', linewidth=2)\n",
        "ax2.axvline(true_population_mean, color='orange', linewidth=3, label=f'True Mean = {true_population_mean}')\n",
        "ax2.set_title('Our Sample and Confidence Interval')\n",
        "ax2.set_xlabel('Height (inches)')\n",
        "ax2.set_ylabel('Density')\n",
        "ax2.legend()\n",
        "ax2.grid(True, alpha=0.3)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "print(f\"Capture rate: {sum(captures)}/{n_intervals} = {sum(captures)/n_intervals*100:.1f}%\")\n",
        "print(\"This should be close to 95%!\")"
      ],
      "id": "e9dbf452",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.task-box}\n",
        "### Task 4: Your Own Confidence Interval\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 8 minutes\n",
        ":::\n",
        "\n",
        "You're studying the average time students spend on homework per week. You survey 40 students and get the following results:\n",
        "\n",
        "Copy the below code and try it on your own!"
      ],
      "id": "591b226c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "# Homework time data (in hours per week)\n",
        "np.random.seed(456)\n",
        "homework_data = np.random.normal(15, 5, 40)  # 40 students, roughly normal\n",
        "\n",
        "print(\"Homework Survey Results:\")\n",
        "print(f\"Sample size: {len(homework_data)}\")\n",
        "print(f\"Sample mean: {np.mean(homework_data):.2f} hours/week\")\n",
        "print(f\"Sample std dev: {np.std(homework_data, ddof=1):.2f} hours/week\")\n",
        "\n",
        "# Your task: Create a 90% confidence interval\n",
        "# Step 1: Calculate the needed values\n",
        "sample_mean = np.mean(homework_data)\n",
        "sample_std = np.std(homework_data, ddof=1)\n",
        "n = len(homework_data)\n",
        "\n",
        "# Step 2: Find the critical value for 90% confidence\n",
        "confidence = 0.90\n",
        "alpha = 1 - confidence\n",
        "z_star = stats.norm.ppf(1 - alpha/2)\n",
        "print(f\"Critical value for 90% confidence: {z_star:.3f}\")\n",
        "\n",
        "# Step 3: Calculate standard error and margin of error\n",
        "standard_error = sample_std / np.sqrt(n)\n",
        "margin_of_error = z_star * standard_error\n",
        "\n",
        "print(f\"Standard error: {standard_error:.3f}\")\n",
        "print(f\"Margin of error: {margin_of_error:.3f}\")\n",
        "\n",
        "# Step 4: Build the confidence interval\n",
        "ci_lower = sample_mean - margin_of_error\n",
        "ci_upper = sample_mean + margin_of_error\n",
        "\n",
        "print(f\"\\n90% Confidence Interval for average homework time:\")\n",
        "print(f\"[{ci_lower:.2f}, {ci_upper:.2f}] hours per week\")\n",
        "\n",
        "# Step 5: Interpret your result\n",
        "print(f\"\\nInterpretation:\")\n",
        "print(f\"We are 90% confident that the true average homework time\")\n",
        "print(f\"for all students is between {ci_lower:.2f} and {ci_upper:.2f} hours per week.\")"
      ],
      "id": "58ed1c44",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Questions to think about:**\n",
        "\n",
        "1. How would a 95% confidence interval compare to your 90% interval?\n",
        "   \n",
        "2. What if you had surveyed 100 students instead of 40?\n",
        "\n",
        ":::\n",
        "\n",
        "## Different Confidence Levels"
      ],
      "id": "3a3db68a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# Compare different confidence levels using our height data\n",
        "confidence_levels = [0.80, 0.90, 0.95, 0.99]\n",
        "\n",
        "print(\"Comparison of Confidence Intervals:\")\n",
        "print(\"=\" * 50)\n",
        "\n",
        "for conf in confidence_levels:\n",
        "    alpha = 1 - conf\n",
        "    z_crit = stats.norm.ppf(1 - alpha/2)\n",
        "    margin = z_crit * standard_error\n",
        "    \n",
        "    lower = sample_mean - margin\n",
        "    upper = sample_mean + margin\n",
        "    width = upper - lower\n",
        "    \n",
        "    print(f\"{conf*100:2.0f}% CI: [{lower:.2f}, {upper:.2f}], width = {width:.2f}\")\n",
        "\n",
        "print()\n",
        "print(\"Notice: Higher confidence = Wider interval!\")\n",
        "print(\"Trade-off: Confidence vs. Precision\")"
      ],
      "id": "9120612c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Part 6: Practice - Real World Applications\n",
        "\n",
        "\n",
        "::: {.task-box}\n",
        "### Task 5: Which Distribution Should I Use?\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 4 minutes\n",
        ":::\n",
        "\n",
        "Match each scenario with the best distribution:\n",
        "\n",
        "**Scenarios:**\n",
        "\n",
        "A. Time between customer arrivals at a coffee shop\n",
        "\n",
        "B. Heights of adult women  \n",
        "\n",
        "C. The outcome of rolling a fair 6-sided die\n",
        "\n",
        "D. Temperature measurements in a city\n",
        "\n",
        "E. Whether a coin flip shows heads or tails\n",
        "\n",
        "**Distributions:**\n",
        "\n",
        "1. Normal\n",
        "   \n",
        "2. Uniform  \n",
        "   \n",
        "3. Exponential\n",
        "   \n",
        "4. Discrete uniform\n",
        "   \n",
        "5. Bernoulli"
      ],
      "id": "6ca03ab9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "# Fill in your answers:\n",
        "print(\"My answers:\")\n",
        "print(\"A. Time between arrivals: ___\")      # Fill in the number\n",
        "print(\"B. Heights: ___\")                    # Fill in the number\n",
        "print(\"C. Die roll: ___\")                   # Fill in the number\n",
        "print(\"D. Temperature: ___\")                # Fill in the number\n",
        "print(\"E. Coin flip: ___\")                  # Fill in the number\n",
        "\n",
        "# Check your reasoning - why did you choose each one?"
      ],
      "id": "9a3103a5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "# Part 6: Simulation - The Law of Large Numbers (Optional)\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 5 minutes\n",
        ":::\n",
        "\n",
        "Let's see how sample means get closer to the population mean as we increase sample size:"
      ],
      "id": "6ebd3c19"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "# The Law of Large Numbers in action\n",
        "population = stats.norm(50, 10)  # Population: mean=50, std=10\n",
        "true_mean = population.mean()\n",
        "\n",
        "sample_sizes = [5, 10, 20, 50, 100, 200, 500, 1000]\n",
        "sample_means = []\n",
        "\n",
        "print(\"Law of Large Numbers: Sample means approaching population mean\")\n",
        "print(\"=\" * 60)\n",
        "print(f\"True population mean: {true_mean}\")\n",
        "print()\n",
        "\n",
        "for n in sample_sizes:\n",
        "    sample = population.rvs(n)\n",
        "    sample_mean = np.mean(sample)\n",
        "    sample_means.append(sample_mean)\n",
        "    error = abs(sample_mean - true_mean)\n",
        "    print(f\"n={n:4d}: sample mean = {sample_mean:6.2f}, error = {error:.2f}\")\n",
        "\n",
        "# Visualize convergence\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(sample_sizes, sample_means, 'bo-', linewidth=2, markersize=8, label='Sample Means')\n",
        "plt.axhline(true_mean, color='red', linestyle='--', linewidth=2, \n",
        "           label=f'True Population Mean = {true_mean}')\n",
        "plt.xlabel('Sample Size')\n",
        "plt.ylabel('Sample Mean')\n",
        "plt.title('Law of Large Numbers: Sample Means Converge to Population Mean')\n",
        "plt.legend()\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.show()\n",
        "\n",
        "print(f\"\\nAs sample size increases, sample means get closer to {true_mean}!\")"
      ],
      "id": "54b9dc25",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Summary: What We Learned Today\n",
        "\n",
        "::: {.time-box}\n",
        "⏱️ **Estimated time:** 3 minutes\n",
        ":::\n",
        "\n",
        "🎉 **Congratulations!** You've learned about:\n",
        "\n",
        "1. **Continuous vs. Discrete Variables**\n",
        "   - Discrete: Count things (use PMF)\n",
        "   - Continuous: Measure things (use PDF, calculate areas)\n",
        "\n",
        "2. **Important Continuous Distributions**:\n",
        "   - **Normal**: The bell curve (heights, test scores, errors)\n",
        "   - **Uniform**: All values equally likely  \n",
        "   - **Exponential**: Waiting times, time between events\n",
        "\n",
        "3. **Central Limit Theorem**: Sample means are approximately normal, no matter what the population looks like!\n",
        "\n",
        "4. **Confidence Intervals**: A range of plausible values for a population parameter\n",
        "   - Higher confidence = wider interval\n",
        "   - Larger sample = narrower interval\n",
        "\n",
        "5. **Python Tools for Continuous Distributions**:\n",
        "   - `stats.norm(mean, std)` - Normal distribution\n",
        "   - `stats.uniform(start, width)` - Uniform distribution  \n",
        "   - `stats.expon(scale)` - Exponential distribution\n",
        "   - `.pdf()`, `.cdf()`, `.ppf()` methods\n",
        "\n",
        "::: {.callout-tip}\n",
        "## Key Formulas to Remember\n",
        "\n",
        "**95% Confidence Interval for a mean:**\n",
        "$$\\bar{x} \\pm 1.96 \\times \\frac{s}{\\sqrt{n}}$$\n",
        "\n",
        "**Central Limit Theorem:**\n",
        "Sample means follow $\\text{Normal}\\left(\\mu, \\frac{\\sigma}{\\sqrt{n}}\\right)$\n",
        "\n",
        "**68-95-99.7 Rule:**\n",
        "- 68% within 1 standard deviation\n",
        "- 95% within 2 standard deviations  \n",
        "- 99.7% within 3 standard deviations\n",
        ":::\n",
        "\n",
        "## What's Next?\n",
        "\n",
        "In lab 6, our final lab; we'll learn about:\n",
        "\n",
        "- Hypothesis testing (is a claim supported by data?)\n",
        "- Comparing two groups (t-tests)\n",
        "- Relationships between variables (correlation, regression)\n",
        "\n",
        "Great job tackling lab 5 and learning about continuous random variables and confidence intervals! 📊🎯\n",
        "\n",
        "::: {.callout-note}\n",
        "## Quick Reference: Python Commands\n",
        "\n",
        "```python\n",
        "# Normal distribution\n",
        "norm_dist = stats.norm(mean, std)\n",
        "\n",
        "# Uniform distribution  \n",
        "uniform_dist = stats.uniform(start, width)\n",
        "\n",
        "# Exponential distribution\n",
        "exp_dist = stats.expon(scale=mean)\n",
        "\n",
        "# Calculate probabilities\n",
        "prob = dist.cdf(x)              # P(X ≤ x)\n",
        "prob = dist.cdf(b) - dist.cdf(a) # P(a < X < b)\n",
        "\n",
        "# Get percentiles\n",
        "value = dist.ppf(0.95)          # 95th percentile\n",
        "\n",
        "# Generate random samples\n",
        "sample = dist.rvs(size=100)     # 100 random values\n",
        "\n",
        "# Confidence interval (95%)\n",
        "z_star = stats.norm.ppf(0.975)  # Critical value\n",
        "margin = z_star * (std / np.sqrt(n))\n",
        "ci = [mean - margin, mean + margin]\n",
        "```\n",
        ":::\n",
        "\n",
        "---\n",
        "\n",
        "::: {.task-box}\n",
        "### **Bonus Challenge**: \n",
        "Try changing the parameters in any of the examples above and see how the distributions change. What happens to confidence intervals when you change the confidence level or sample size? Experiment and explore! 🔬\n",
        "\n",
        ":::"
      ],
      "id": "5fd99d94"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "pstat5a",
      "language": "python",
      "display_name": "Python (pstat5a)",
      "path": "/Users/narjesmathlouthi/Library/Jupyter/kernels/pstat5a"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}